---
title: "Python SDK"
description: "Official Python SDK for Blindfold - Comprehensive Guide"
---

The official Python SDK for Blindfold provides a simple and powerful way to protect sensitive data in your Python applications. It supports both synchronous and asynchronous operations.

## Installation

Install the SDK using pip:

```bash
pip install blindfold-sdk
```

## Initialization

### Basic Setup

```python
from blindfold import Blindfold

client = Blindfold(
    api_key="your-api-key-here"
)
```

### With Region Selection

```python
from blindfold import Blindfold

# Process data in the US region
client = Blindfold(
    api_key="your-api-key-here",
    region="us"
)

# Process data in the EU region (default)
client = Blindfold(
    api_key="your-api-key-here",
    region="eu"
)
```

See [Regions](/essentials/regions) for available regions and data residency details.

### With Custom Configuration

```python
from blindfold import Blindfold

client = Blindfold(
    api_key="your-api-key-here",
    base_url="https://api.blindfold.dev/api/public/v1",  # Optional: Custom API endpoint
    user_id="user_123"  # Optional: Track specific user for audit logs
)
```

### Context Manager (Recommended)

Use the context manager to ensure proper resource cleanup:

```python
from blindfold import Blindfold

with Blindfold(api_key="your-api-key-here") as client:
    response = client.tokenize("Hello John Doe")
    print(response.text)
```

## Policy-Based Detection

Blindfold supports **policy-based PII detection** for simplified configuration and compliance. Use pre-configured policies instead of manually specifying entities and thresholds.

### Available Global Policies

- **`basic`** - Minimal PII detection (threshold: 0.30) - Fast, general purpose
- **`gdpr_eu`** - GDPR EU compliant (threshold: 0.35) - European data protection
- **`hipaa_us`** - HIPAA compliant (threshold: 0.40) - US healthcare compliance
- **`pci_dss`** - PCI DSS compliant (threshold: 0.45) - Payment card industry
- **`strict`** - Maximum detection (threshold: 0.25) - Comprehensive protection

### Using Policies

```python
# Use a policy instead of specifying entities
response = client.tokenize(
    text="Contact John Doe at john@example.com",
    policy="gdpr_eu"  # GDPR-compliant detection
)

```

<Info>
  Policies simplify your code and ensure consistent PII detection across your application. You can manage policies through the dashboard.
</Info>

## Core Methods

### Detect

Detect PII in text without modifying it. Returns only the detected entities with their types, positions, and confidence scores.

```python
# Using a policy
response = client.detect(
    text="Contact John Doe at john@example.com or call +1-555-1234",
    policy="gdpr_eu"
)

print(response.entities_count)
# 3

for entity in response.detected_entities:
    print(f"{entity.type}: {entity.text} (confidence: {entity.score:.2f})")
# Person: John Doe (confidence: 0.99)
# Email Address: john@example.com (confidence: 0.98)
# Phone Number: +1-555-1234 (confidence: 0.95)
```

**Parameters:**
- `text` (str, required): The text to analyze
- `policy` (str, optional): Policy name (e.g., `gdpr_eu`, `hipaa_us`)
- `entities` (list[str], optional): List of entity types to detect
- `score_threshold` (float, optional): Minimum confidence score (0.0-1.0)

**Returns:** `DetectResponse` with:
- `detected_entities`: List of detected entities with details
- `entities_count`: Total number of entities found

### Tokenize

Replace sensitive data with reversible tokens. Perfect for AI interactions where you need to restore original values later.

```python
# Method 1: Using a policy (recommended)
response = client.tokenize(
    text="Contact John Doe at john@example.com or call +1-555-1234",
    policy="gdpr_eu"
)

# Method 2: Manual configuration
response = client.tokenize(
    text="Contact John Doe at john@example.com or call +1-555-1234",
    config={
        "entities": ["person", "email address", "phone number"],  # Natural language entity names
        "score_threshold": 0.4  # Optional: Confidence threshold (0.0-1.0)
    }
)

print(response.text)
# "Contact <person_1> at <email_address_1> or call <phone_number_1>"

print(response.mapping)
# {'<person_1>': 'John Doe', '<email_address_1>': 'john@example.com', '<phone_number_1>': '+1-555-1234'}

print(response.entities_count)
# 3

for entity in response.detected_entities:
    print(f"{entity.type}: {entity.text} (confidence: {entity.score:.2f})")
```

**Parameters:**
- `text` (str, required): The text to tokenize
- `policy` (str, optional): Policy name (e.g., `gdpr_eu`, `hipaa_us`)
- `config` (dict, optional):
  - `entities` (list[str]): List of entity types to detect (use natural language names like `"person"`, `"email address"`)
  - `score_threshold` (float): Minimum confidence score (0.0-1.0)

**Returns:** `TokenizeResponse` with:
- `text`: Anonymized text with tokens
- `mapping`: Dictionary mapping tokens to original values
- `detected_entities`: List of detected entities with details
- `entities_count`: Total number of entities found

### Detokenize

Restore original values from tokens.

```python
original = client.detokenize(
    text="AI response for <PERSON_1> at <EMAIL_ADDRESS_1>",
    mapping=response.mapping
)

print(original.text)
# "AI response for John Doe at john@example.com"

print(original.replacements_made)
# 2
```

**Parameters:**
- `text` (str, required): Text containing tokens
- `mapping` (dict, required): Token-to-value mapping from tokenize response

**Returns:** `DetokenizeResponse` with:
- `text`: Original text with tokens replaced
- `replacements_made`: Number of token replacements

### Mask

Partially hide sensitive data (e.g., `****-****-****-1234`).

```python
response = client.mask(
    text="Credit card: 4532-7562-9102-3456",
    masking_char="*",
    chars_to_show=4,
    from_end=True
)

print(response.text)
# "Credit card: ***************3456"
```

**Parameters:**
- `text` (str, required): Text to mask
- `masking_char` (str, optional): Character to use for masking (default: `*`)
- `chars_to_show` (int, optional): Number of characters to keep visible (default: 4)
- `from_end` (bool, optional): Show characters from end if True, start if False (default: True)

**Returns:** `MaskResponse` with:
- `text`: Masked text
- `detected_entities`: List of detected and masked entities
- `entities_count`: Number of entities masked

### Redact

Permanently remove sensitive data.

```python
response = client.redact(
    text="My SSN is 123-45-6789 and password is secret123"
)

print(response.text)
# "My SSN is <US_SSN> and password is <PASSWORD>"
```

**Parameters:**
- `text` (str, required): Text to redact
- `entities` (list[str], optional): Specific entity types to redact
- `score_threshold` (float, optional): Minimum confidence score

**Returns:** `RedactResponse` with:
- `text`: Redacted text
- `detected_entities`: List of redacted entities
- `entities_count`: Number of entities redacted

### Hash

Replace data with deterministic hashes. Useful for analytics and matching without exposing original values.

```python
response = client.hash(
    text="User ID: john@example.com purchased item X",
    hash_type="sha256",
    hash_prefix="ID_",
    hash_length=16
)

print(response.text)
# "User ID: ID_a3f8b9c2d4e5f6g7 purchased item X"
```

**Parameters:**
- `text` (str, required): Text to hash
- `hash_type` (str, optional): Hash algorithm - `md5`, `sha1`, `sha224`, `sha256`, `sha384`, `sha512` (default: `sha256`)
- `hash_prefix` (str, optional): Prefix for hash values (default: `""`)
- `hash_length` (int, optional): Length of hash to use (default: 16)

**Returns:** `HashResponse` with:
- `text`: Text with hashed entities
- `detected_entities`: List of hashed entities
- `entities_count`: Number of entities hashed

### Synthesize

Replace real data with realistic fake data using Faker.

```python
response = client.synthesize(
    text="John lives in New York and works at Microsoft",
    language="en"
)

print(response.text)
# "Michael Smith lives in Boston and works at TechCorp" (example output)
```

**Parameters:**
- `text` (str, required): Text to synthesize
- `language` (str, optional): Language code for fake data generation - `en`, `cs`, `de`, `fr`, `es`, `it`, `pl`, `sk` (default: `en`)
- `entities` (list[str], optional): Specific entity types to synthesize
- `score_threshold` (float, optional): Minimum confidence score

**Returns:** `SynthesizeResponse` with:
- `text`: Text with synthesized data
- `detected_entities`: List of replaced entities
- `entities_count`: Number of entities synthesized

### Encrypt

Encrypt sensitive data using AES encryption (reversible with key).

```python
response = client.encrypt(
    text="Secret message: API key is sk-12345",
    encryption_key="your-secure-key-min-16-chars"
)

print(response.text)
# "Secret message: gAAAAABh..." (encrypted string)
```

**Parameters:**
- `text` (str, required): Text to encrypt
- `encryption_key` (str, optional): Encryption key (min 16 characters). If not provided, uses tenant default.
- `entities` (list[str], optional): Specific entity types to encrypt
- `score_threshold` (float, optional): Minimum confidence score

**Returns:** `EncryptResponse` with:
- `text`: Text with encrypted entities
- `detected_entities`: List of encrypted entities
- `entities_count`: Number of entities encrypted

## Image Processing

Process PII in images — upload an image, and receive a modified PNG with PII protected. All image methods return an `ImageProcessResponse` containing the processed image bytes and metadata.

### ImageProcessResponse

| Field | Type | Description |
|-------|------|-------------|
| `image` | `bytes` | Processed PNG image |
| `detected_entities` | `list[DetectedEntity]` | Entities found in the image |
| `entities_count` | `int` | Number of entities detected |
| `mapping` | `dict[str, str]` | Token-to-original mapping |
| `ocr_confidence` | `float \| None` | Average OCR confidence (0-100) |

### image_detect()

Detect PII in an image without modifying it. Returns extracted text and entities (JSON, not an image).

```python
result = client.image_detect("screenshot.png")
print(result.extracted_text)
print(result.ocr_confidence)
for entity in result.detected_entities:
    print(f"  {entity.type}: {entity.text}")
```

See [Image Processing](/methods/image-detection) for full details.

### image_tokenize()

Replace PII with token labels in the image.

```python
result = client.image_tokenize("screenshot.png")
with open("tokenized.png", "wb") as f:
    f.write(result.image)
print(result.mapping)
```

### image_redact()

Remove PII with black boxes.

```python
result = client.image_redact("screenshot.png", policy="gdpr_eu")
with open("redacted.png", "wb") as f:
    f.write(result.image)
```

### image_mask()

Partially hide PII with masking characters.

```python
result = client.image_mask(
    "screenshot.png",
    chars_to_show=4,
    from_end=True,
    masking_char="*",
)
with open("masked.png", "wb") as f:
    f.write(result.image)
```

**Extra parameters:** `chars_to_show` (default: 3), `from_end` (default: False), `masking_char` (default: `*`)

### image_synthesize()

Replace PII with realistic fake data.

```python
result = client.image_synthesize("screenshot.png", synthesis_language="de")
with open("synthesized.png", "wb") as f:
    f.write(result.image)
```

**Extra parameter:** `synthesis_language` (default: `en`) — supports `en`, `cs`, `de`, `fr`, `es`, `it`, `pl`, `sk`

### image_hash()

Replace PII with deterministic hashes.

```python
result = client.image_hash(
    "screenshot.png",
    hash_type="sha256",
    hash_prefix="ID_",
    hash_length=12,
)
with open("hashed.png", "wb") as f:
    f.write(result.image)
```

**Extra parameters:** `hash_type` (default: `sha256`), `hash_prefix` (default: `HASH_`), `hash_length` (default: 16)

### image_encrypt()

Encrypt PII with AES encryption.

```python
result = client.image_encrypt(
    "screenshot.png",
    encryption_key="your-secure-key-min-16-chars",
)
with open("encrypted.png", "wb") as f:
    f.write(result.image)
```

**Extra parameter:** `encryption_key` (min 16 characters, uses tenant default if omitted)

### Common Parameters

All image methods accept:

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `image` | `str \| Path \| bytes` | — | Image file path or raw bytes |
| `language` | `str` | `eng` | Tesseract OCR language code |
| `entities` | `list[str]` | `None` | Entity types to detect |
| `score_threshold` | `float` | `None` | Minimum confidence (0.0-1.0) |
| `policy` | `str` | `None` | Detection policy name |

### Async Image Processing

All image methods are available on `AsyncBlindfold`:

```python
async with AsyncBlindfold(api_key="your-key", region="eu") as client:
    result = await client.image_tokenize("screenshot.png")
    with open("tokenized.png", "wb") as f:
        f.write(result.image)
```

## Batch Processing

Process multiple texts in a single API call. All 7 methods (except detokenize) support batch processing.

### Basic Batch Usage

```python
# Tokenize multiple texts at once
result = client.tokenize_batch([
    "Contact John Doe at john@example.com",
    "Jane Smith lives in New York",
    "No sensitive data here"
])

print(result.total)       # 3
print(result.succeeded)   # 3
print(result.failed)      # 0

for item in result.results:
    print(item["text"], item.get("entities_count", 0))
```

### With Configuration

```python
result = client.tokenize_batch(
    ["Text one with PII", "Text two with PII"],
    policy="gdpr_eu",
    entities=["person", "email address"],
    score_threshold=0.5
)
```

### All Batch Methods

```python
# Detection only
result = client.detect_batch(["text1", "text2"])

# Redaction
result = client.redact_batch(["text1", "text2"])

# Masking
result = client.mask_batch(["text1", "text2"], chars_to_show=4, from_end=True)

# Synthesize with fake data
result = client.synthesize_batch(["text1", "text2"], language="de")

# Hash
result = client.hash_batch(["text1", "text2"], hash_type="sha256", hash_length=16)

# Encrypt
result = client.encrypt_batch(["text1", "text2"], encryption_key="your-key-min-16-chars")
```

### Handling Partial Failures

Individual texts can fail without affecting the rest of the batch:

```python
result = client.tokenize_batch(["valid text", "another text"])

for i, item in enumerate(result.results):
    if "error" in item:
        print(f"Text {i} failed: {item['error']}")
    else:
        print(f"Text {i}: {item['text']}")

print(f"{result.succeeded}/{result.total} succeeded")
```

### Async Batch

```python
async with AsyncBlindfold(api_key="your-key") as client:
    result = await client.tokenize_batch(["text1", "text2"], policy="gdpr_eu")
```

**Limits:**
- Maximum 100 texts per batch
- Each text: max 100,000 characters
- Shared config (policy, entities, score_threshold) applies to all texts

**Returns:** `BatchResponse` with:
- `results`: List of individual results (same shape as single-text responses)
- `total`: Number of texts submitted
- `succeeded`: Number of successfully processed texts
- `failed`: Number of failed texts

## Async Support

The SDK fully supports asyncio for non-blocking operations:

```python
import asyncio
from blindfold import AsyncBlindfold

async def main():
    async with AsyncBlindfold(api_key="your-api-key-here") as client:
        # All methods are available with async/await
        response = await client.tokenize("Hello John Doe")
        print(response.text)

        # Concurrent requests
        results = await asyncio.gather(
            client.tokenize("Text 1 with john@example.com"),
            client.tokenize("Text 2 with jane@example.com"),
            client.mask("Card: 4532-7562-9102-3456")
        )

asyncio.run(main())
```

## Policy Management

Manage custom policies for your organization.

### List Policies

```python
# List all available policies
policies = client.list_policies()

for policy in policies['global_policies']:
    print(f"{policy['name']}: {policy['description']}")

for policy in policies['custom_policies']:
    print(f"Custom: {policy['name']} (threshold: {policy['threshold']})")
```

### Get Policy Details

```python
# Get specific policy configuration
policy = client.get_policy("gdpr_eu")
print(f"Entities: {policy['entities']}")
print(f"Threshold: {policy['threshold']}")
```

### Create Custom Policy

```python
# Create a custom policy
custom_policy = client.create_policy(
    name="internal_hr_policy",
    entities=[
        "person",
        "email address",
        "social security number",
        "date of birth",
        "phone number"
    ],
    threshold=0.45,
    description="HR department policy for employee data"
)

print(f"Created policy: {custom_policy['id']}")

# Use the custom policy
response = client.tokenize(
    text="Employee: John Doe, SSN: 123-45-6789",
    policy="internal_hr_policy"
)
```

### Update Custom Policy

```python
# Update an existing custom policy
updated_policy = client.update_policy(
    policy_id="123e4567-e89b-12d3-a456-426614174000",
    threshold=0.50,
    description="Updated HR policy with stricter threshold"
)
```

### Delete Custom Policy

```python
# Delete a custom policy (cannot delete global policies)
client.delete_policy(policy_id="123e4567-e89b-12d3-a456-426614174000")
```

## Supported Entity Types

The SDK automatically detects 60+ types of sensitive information using **natural language names** (lowercase):

### Personal Information
- `person` - Person names
- `email` / `email address` - Email addresses
- `phone number` / `mobile phone number` - Phone numbers
- `date of birth` - Birth dates
- `blood type` - Blood type classification

### Financial Information
- `credit card number` - Credit card numbers
- `credit card brand` - Card issuers (Visa, Mastercard, etc.)
- `cvv` / `cvc` - Card verification codes
- `iban` - International Bank Account Numbers
- `bank account number` - Bank accounts
- `tax identification number` - Tax IDs

### Government IDs
- `social security number` - Social security numbers
- `passport number` - Passport numbers
- `driver's license number` - Driver's licenses
- `national id number` - National ID cards
- `cpf` - Brazilian individual taxpayer ID
- `cnpj` - Brazilian company registry

### Healthcare Information
- `health insurance number` - Health insurance IDs
- `medical condition` - Medical diagnoses
- `medication` - Medication names
- `insurance company` - Insurance providers

### Technical Information
- `ip address` - IP addresses (IPv4/IPv6)
- `username` - User identifiers
- `social media handle` - Social media usernames

### Travel & Transactions
- `flight number` - Airline flight numbers
- `reservation number` - Booking confirmations
- `transaction number` - Transaction IDs

### Registration
- `license plate number` - Vehicle plates
- `student id number` - Student IDs
- `serial number` - Product serial numbers

<Info>
  See the complete list of 60+ entity types in the [Supported Entities](/essentials/supported-entities) documentation.
</Info>

## Error Handling

The SDK provides specific exception types for different error scenarios:

```python
from blindfold import Blindfold, AuthenticationError, APIError, NetworkError

try:
    with Blindfold(api_key="invalid-key") as client:
        response = client.tokenize("Test")
except AuthenticationError as e:
    print(f"Invalid API key: {e.message}")
except APIError as e:
    print(f"API error ({e.status_code}): {e.message}")
except NetworkError as e:
    print(f"Network error: {e.message}")
except Exception as e:
    print(f"Unexpected error: {e}")
```

**Exception Types:**
- `AuthenticationError` - Invalid or missing API key
- `APIError` - API validation or processing errors (includes status code)
- `NetworkError` - Connection issues, timeouts
- `Exception` - Unexpected errors

## Configuration Options

### Entity Filtering

Filter which types of entities to detect:

```python
response = client.tokenize(
    text="Contact John at john@example.com or 555-1234",
    config={
        "entities": ["EMAIL_ADDRESS"]  # Only detect emails
    }
)
```

### Confidence Threshold

Set minimum confidence score (0.0-1.0) for entity detection:

```python
response = client.tokenize(
    text="Maybe this is an email: test@test",
    config={
        "score_threshold": 0.8  # Only high-confidence detections
    }
)
```

Lower threshold = more detections (higher recall, lower precision)
Higher threshold = fewer detections (lower recall, higher precision)

## Best Practices

### 1. Use Environment Variables for API Keys

```python
import os
from blindfold import Blindfold

api_key = os.environ.get("BLINDFOLD_API_KEY")
client = Blindfold(api_key=api_key)
```

### 2. Use Context Managers

```python
# Good - ensures proper cleanup
with Blindfold(api_key=api_key) as client:
    response = client.tokenize(text)

# Avoid - requires manual cleanup
client = Blindfold(api_key=api_key)
response = client.tokenize(text)
client.close()
```

### 3. Handle Errors Gracefully

```python
try:
    response = client.tokenize(text)
except AuthenticationError:
    # Refresh API key or notify admin
    pass
except NetworkError:
    # Retry with exponential backoff
    pass
```

### 4. Store Mappings Securely

When using tokenization, store the mapping securely for later detokenization:

```python
# Tokenize
response = client.tokenize(user_input)
# Store mapping in secure session storage or encrypted database
session['token_mapping'] = response.mapping

# Later, detokenize
ai_response = get_ai_response(response.text)
original = client.detokenize(ai_response, session['token_mapping'])
```

### 5. Use Async for High-Throughput Applications

```python
async with AsyncBlindfold(api_key=api_key) as client:
    # Process multiple requests concurrently
    tasks = [client.tokenize(text) for text in texts]
    results = await asyncio.gather(*tasks)
```

## Complete Examples

### Example 1: OpenAI Integration with GDPR Policy

```python
import os
from blindfold import Blindfold
from openai import OpenAI

# Initialize clients
blindfold = Blindfold(api_key=os.environ["BLINDFOLD_API_KEY"])
openai_client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

# User input with sensitive data
user_message = "My name is John Doe, email john@example.com, phone +49 30 12345678"

# 1. Tokenize sensitive data using GDPR policy
protected = blindfold.tokenize(
    text=user_message,
    policy="gdpr_eu"  # GDPR-compliant detection
)
print(f"Protected: {protected.text}")
# Output: "My name is <person_1>, email <email_address_1>, phone <phone_number_1>"

# 2. Send protected text to OpenAI
ai_response = openai_client.chat.completions.create(
    model="gpt-4",
    messages=[{"role": "user", "content": protected.text}]
)

ai_text = ai_response.choices[0].message.content

# 3. Detokenize AI response to restore original data
final_response = blindfold.detokenize(ai_text, protected.mapping)
print(f"Final: {final_response.text}")
```

### Example 2: Healthcare Data with HIPAA Policy

```python
import os
from blindfold import Blindfold

client = Blindfold(api_key=os.environ["BLINDFOLD_API_KEY"])

# Patient data with sensitive information
patient_data = """
Patient: Jane Smith
DOB: 1985-04-12
SSN: 123-45-6789
Health Insurance: ABC123456
Diagnosis: Type 2 Diabetes
Medication: Metformin 500mg
"""

# Redact using HIPAA policy
redacted = client.redact(
    text=patient_data,
    policy="hipaa_us"  # HIPAA-compliant redaction
)

print(f"Redacted data:\n{redacted.text}")
print(f"Protected {redacted.entities_count} entities")
```

### Example 3: Custom Policy for Internal Use

```python
import os
from blindfold import Blindfold

client = Blindfold(api_key=os.environ["BLINDFOLD_API_KEY"])

# Create a custom policy for HR department
hr_policy = client.create_policy(
    name="hr_employee_data",
    entities=[
        "person",
        "email address",
        "social security number",
        "date of birth",
        "phone number",
        "address"
    ],
    threshold=0.45,
    description="HR department employee data protection"
)

print(f"Created policy: {hr_policy['name']}")

# Use the custom policy
employee_data = "Employee: John Doe, SSN: 123-45-6789, DOB: 1990-05-15, Phone: +1-555-1234"

protected = client.tokenize(
    text=employee_data,
    policy="hr_employee_data"
)

print(f"Protected: {protected.text}")
# All employee PII is tokenized according to HR policy
```

### Example 4: Async with Policy

```python
import asyncio
import os
from blindfold import AsyncBlindfold

async def process_batch():
    async with AsyncBlindfold(api_key=os.environ["BLINDFOLD_API_KEY"]) as client:
        # Process multiple texts with GDPR policy
        texts = [
            "Customer: John Doe, john@example.com",
            "User: Jane Smith, jane@example.com",
            "Client: Bob Wilson, bob@example.com"
        ]

        # Concurrent processing with policy
        tasks = [
            client.tokenize(text, policy="gdpr_eu")
            for text in texts
        ]

        results = await asyncio.gather(*tasks)

        for i, result in enumerate(results):
            print(f"Protected {i+1}: {result.text}")

asyncio.run(process_batch())
```

## Need Help?

- **GitHub Issues**: Report bugs or request features
- **Email Support**: hello@blindfold.dev
- **Documentation**: Check out the [API Reference](/api-reference/rest-api) and [Examples](/examples)
